<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>C# test examples | bUnit </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="C# test examples | bUnit ">
    <meta name="generator" content="docfx 2.53.1.0">
    <meta name="description" content="bUnit is a unit testing library for Blazor Components. You can easily define components under test in C# or Razor syntax and verify outcome using semantic HTML diffing/comparison logic. You can interact with and inspect components, trigger event handlers, provide cascading values, inject services, mock IJsRuntime, and perform snapshot testing.">
    <!--<link rel="shortcut icon" href="../favicon.ico">-->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img height="60%" id="logo" class="img" src="..//images/blazor-logo.png" alt="bUnit">
                <span>bUnit</span>
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="c-test-examples">C# test examples</h1>

<blockquote>
<p><strong>WARNING:</strong> These examples are somewhat outdated. Some content in here might still apply:</p>
</blockquote>
<p>In the following examples, the terminology <strong>component under test</strong> (abbreviated CUT) is used to mean the component that is the target of the test. The examples below use the <code>Shouldly</code> assertion library as well. If you prefer not to use that just replace the assertions with the ones from your own favorite assertion library.</p>
<p>All examples can be found in the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/tests/Tests">Tests</a> folder in the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/">Sample project</a>.</p>
<h2 id="testing-components-without-parameters">Testing components without parameters</h2>
<p>The following unit-tests verifies that the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Pages/Counter.razor">Counter.razor</a> component behaves correctly. Here is the source for the Counter component:</p>
<pre><code class="lang-razor">@page &quot;/counter&quot;

&lt;h1&gt;Counter&lt;/h1&gt;

&lt;p&gt;
    Current count: @currentCount
&lt;/p&gt;

&lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&gt;Click me&lt;/button&gt;

@code {
    int currentCount = 0;

    void IncrementCount()
    {
        currentCount++;
    }
}
</code></pre>
<p>The <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/tests/Tests/Pages/CounterTest.cs">CounterTest.cs</a> looks like this:</p>
<pre><code class="lang-csharp">public class CounterTest : ComponentTestFixture
{
    [Fact]
    public void InitialHtmlIsCorrect()
    {
        // Arrange - renders the Counter component
        var cut = RenderComponent&lt;Counter&gt;();

        // Assert
        // Here we specify expected HTML from CUT.
        var expectedHtml = @&quot;&lt;h1&gt;Counter&lt;/h1&gt;
                                &lt;p&gt;Current count: 0&lt;/p&gt;
                                &lt;button class=&quot;&quot;btn-primary btn&quot;&quot;&gt;Click me&lt;/button&gt;&quot;;

        // Here we use the HTML diffing library to assert that the rendered HTML
        // from CUT is semantically the same as the expected HTML string above.
        cut.MarkupMatches(expectedHtml);
    }

    [Fact]
    public void ClickingButtonIncreasesCountStrict()
    {
        // Arrange - renders the Counter component
        var cut = RenderComponent&lt;Counter&gt;();

        // Act
        // Use a Find to query the rendered DOM tree and find the button element
        // and trigger the @onclick event handler by calling Click
        cut.Find(&quot;button&quot;).Click();

        // Assert
        // GetChangesSinceFirstRender returns list of differences since the first render,
        // in which we assert that there should only be one change, a text change where
        // the new value is provided to the ShouldHaveSingleTextChange assert method.
        cut.GetChangesSinceFirstRender().ShouldHaveSingleTextChange(&quot;Current count: 1&quot;);

        // Repeat the above steps to ensure that counter works for multiple clicks
        cut.Find(&quot;button&quot;).Click();
        cut.GetChangesSinceFirstRender().ShouldHaveSingleTextChange(&quot;Current count: 2&quot;);
    }

    [Fact]
    public void ClickingButtonIncreasesCountTargeted()
    {
        // Arrange - renders the Counter component
        var cut = RenderComponent&lt;Counter&gt;();

        // Act
        // Use a Find to query the rendered DOM tree and find the button element
        // and trigger the @onclick event handler by calling Click
        cut.Find(&quot;button&quot;).Click();

        // Assert
        // Use a Find to query the rendered DOM tree and find the paragraph element
        // and assert that its text content is the expected (calling Trim first to remove insignificant whitespace)
        cut.Find(&quot;p&quot;).TextContent.Trim().ShouldBe(&quot;Current count: 1&quot;);

        // Repeat the above steps to ensure that counter works for multiple clicks
        cut.Find(&quot;button&quot;).Click();
        cut.Find(&quot;p&quot;).TextContent.Trim().ShouldBe(&quot;Current count: 2&quot;);
    }
}
</code></pre>
<p>A few things worth noting about the tests above:</p>
<ol>
<li><p><code>InitialHtmlIsCorrect</code> uses the <code>ShouldBe</code> method that performs a semantic comparison of the generated HTML from CUT and the expected HTML string. That ensures that insignificant whitespace doesn't give false positives, among other things.</p>
</li>
<li><p>The &quot;<strong>strict</strong>&quot; test (<code>ClickingButtonIncreasesCountStrict</code>) and the &quot;<strong>targeted</strong>&quot; test (<code>ClickingButtonIncreasesCountTargeted</code>) takes two different approaches to verifying CUT renders the expected output:</p>
<ul>
<li>The <strong>strict</strong> version generates a diff between the initial rendered HTML and the rendered HTML after the button click, and then asserts that the compare result only contains the expected change.</li>
<li>The <strong>targeted</strong> version finds the <code>&lt;p&gt;</code> element expect to have changed, and asserts against its text content.</li>
</ul>
<p>With the <em>targeted</em> version, we cannot guarantee that there are not other changes in other places of the rendered HTML, if that is a concern, use the strict style. If it is not, then the targeted style can lead to simpler test.</p>
</li>
</ol>
<h2 id="testing-components-with-parameters">Testing components with parameters</h2>
<p>In the following tests we will pass regular parameters to a component under test, e.g. <code>[Parameter] public SomeType PropName { get; set; }</code> style properties, where <code>SomeType</code> <strong>is not</strong> a <code>RenderFragment</code> or a <code>EventCallback</code> type.</p>
<p>The component under test will be the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Components/Aside.razor">Aside.razor</a> component, which looks like this:</p>
<pre><code class="lang-cshtml">&lt;aside @attributes=&quot;Attributes&quot;&gt;
    @if (Header is { })
    {
        &lt;header&gt;@Header&lt;/header&gt;
    }
    @ChildContent
&lt;/aside&gt;
@code {
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary&lt;string, object&gt;? Attributes { get; set; }

    [Parameter] public string? Header { get; set; }

    [Parameter] public RenderFragment? ChildContent { get; set; }
}
</code></pre>
<p>The <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/tests/Tests/Components/AsideTest.cs">AsideTest.cs</a> looks like this:</p>
<pre><code class="lang-csharp">public class AsideTest : ComponentTestFixture
{
    [Fact(DisplayName = &quot;Aside should render header and additional parameters correctly&quot;)]
    public void Test001()
    {
        // Arrange
        var header = &quot;Hello testers&quot;;
        var cssClass = &quot;some-class&quot;;

        // Act - render the Aside component with two parameters (passed as pairs of name, value tuples).
        // Note the use of the nameof operator to get the name of the Header parameter. This
        // helps keeps the test passing if the name of the parameter is refactored.
        //
        // This is equivalent to the follow Razor code:
        //
        // &lt;Aside Header=&quot;Hello testers&quot; class=&quot;some-class&quot;&gt;
        // &lt;/Aside&gt;
        var cut = RenderComponent&lt;Aside&gt;(
            (nameof(Aside.Header), header),
            (&quot;class&quot;, cssClass)
        );

        // Assert - verify that the rendered HTML from the Aside component matches the expected output.
        cut.MarkupMatches($@&quot;&lt;aside class=&quot;&quot;{cssClass}&quot;&quot;&gt;&lt;header&gt;{header}&lt;/header&gt;&lt;/aside&gt;&quot;);
    }
}
</code></pre>
<p>In the test above, we use an overload of the <code>RenderComponent&lt;TComponent&gt;()</code> method, that allow us to pass regular parameters as pairs of <code>(string name, object? value)</code>.</p>
<p>As highlighted in the code, I recommend using the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/nameof"><code>nameof</code></a> to get the name of declared parameters from the component, so any changes to the name through refactoring automatically updates the test.</p>
<p>The second parameter, <code>class</code> is explicitly declared in the <code>Aside</code> class. It is instead <code>Attributes</code> parameter, that captures all unmatched parameters.</p>
<h3 id="passing-new-parameters-to-an-already-rendered-component">Passing new parameters to an already rendered component</h3>
<p>Sometimes we want to test what happens when a component is re-rendered, possible with new parameters. This can be done using the <code>cut.Render()</code> and the <code>cut.SetParametersAndRender()</code> methods, for example:</p>
<pre><code class="lang-csharp">    [Fact(DisplayName = &quot;Passing new parameters to Aside updates the rendered HTML correctly&quot;)]
    public void Test002()
    {
        // Arrange - initial render of Aside
        var cut = RenderComponent&lt;Aside&gt;();

        // Act - set the Header parameter and re-render the CUT
        cut.SetParametersAndRender((nameof(Aside.Header), &quot;HEADER&quot;));

        // Assert - Check that we have exactly one change since the first render,
        // and that it is an addition to the DOM tree
        cut.GetChangesSinceFirstRender()
            .ShouldHaveSingleChange()
            .ShouldBeAddition(&quot;&lt;header&gt;HEADER&lt;/header&gt;&quot;);

        // Arrange - Create a snapshot of the current rendered HTML for later comparisons
        cut.SaveSnapshot();

        // Act - Set the Header parameter to null again and re-render
        cut.SetParametersAndRender((nameof(Aside.Header), null));

        // Assert - Check that we have exactly one change since compared with the snapshot we took,
        // and that it is an addition to the DOM tree.
        cut.GetChangesSinceSnapshot()
            .ShouldHaveSingleChange()
            .ShouldBeRemoval(&quot;&lt;header&gt;HEADER&lt;/header&gt;&quot;);
    }
</code></pre>
<p>Some notes on <code>Test002</code> above:</p>
<ul>
<li>The <code>cut.SetParametersAndRender()</code> method has the same overloads as the <code>RenderComponent()</code> method.</li>
<li>The <code>ShouldHaveSingleChange()</code> method asserts that only a single difference is found by the compare method, and returns that diff object.</li>
<li>The <code>ShouldBeAddition()</code> method verifies that a difference is an addition with the specified content (doing a semantic HTML comparison).</li>
<li>The <code>cut.TakeSnapshot()</code> method saves the current rendered HTML for later comparisons.</li>
<li>The <code>cut.GetChangesSinceSnapshot()</code> compares the current rendered HTML with the one saved by the <code>TakeSnapshot()</code> method.</li>
</ul>
<h2 id="testing-components-with-child-content">Testing components with child content</h2>
<p>The <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Components/Aside.razor">Aside.razor</a> component listed in the previous section also has a <code>ChildContent</code> parameter, so lets add a few tests that passes markup and components to it through that.</p>
<pre><code class="lang-csharp">public class AsideTest : ComponentTestFixture
{
   [Fact(DisplayName = &quot;Aside should render child markup content correctly&quot;)]
    public void Test003()
    {
        // Arrange
        var content = &quot;&lt;p&gt;I like simple tests and I cannot lie&lt;/p&gt;&quot;;

        // Act
        // Act - render the Aside component with a child content parameter,
        // which is constructed through the ChildContent helper method.
        //
        // This is equivalent to the follow Razor code:
        //
        // &lt;Aside&gt;
        //     &lt;p&gt;I like simple tests and I cannot lie&lt;/p&gt;
        // &lt;/Aside&gt;
        var cut = RenderComponent&lt;Aside&gt;(
            ChildContent(content)
        );

        // Assert - verify that the rendered HTML from the Aside component matches the expected output.
        cut.MarkupMatches($@&quot;&lt;aside&gt;{content}&lt;/aside&gt;&quot;);
    }

    [Fact(DisplayName = &quot;Aside should render a child component correctly&quot;)]
    public void Test004()
    {
        // Arrange - set up test data
        var outerAsideHeader = &quot;Hello outside&quot;;
        var nestedAsideHeader = &quot;Hello inside&quot;;

        // Act - render the Aside component, passing a header to it
        // and a component to its child content. The ChildContent helper
        // method will pass the parameters it is given to the nested Aside
        // component.
        //
        // This is equivalent to the follow Razor code:
        //
        // &lt;Aside Header=&quot;Hello outside&quot;&gt;
        //     &lt;Aside Header=&quot;Hello inside&quot;&gt;&lt;/Aside&gt;
        // &lt;/Aside&gt;
        var cut = RenderComponent&lt;Aside&gt;(
            (nameof(Aside.Header), outerAsideHeader),
            ChildContent&lt;Aside&gt;(
                (nameof(Aside.Header), nestedAsideHeader)
            )
        );

        // Assert - verify that the rendered HTML from the Aside component matches the expected output.
        cut.MarkupMatches($@&quot;&lt;aside&gt;
                            &lt;header&gt;{outerAsideHeader}&lt;/header&gt;
                            &lt;aside&gt;
                                &lt;header&gt;{nestedAsideHeader}&lt;/header&gt;
                            &lt;/aside&gt;
                        &lt;/aside&gt;&quot;);
    }
}
</code></pre>
<ul>
<li>In <code>Test003</code> above we use the <code>ChildContent(...)</code> helper method to create a ChildContent parameter and pass that to the <code>Aside</code> component.</li>
<li>The overload, <code>ChildContent&lt;TComponent&gt;(...)</code>, used in <code>Test004</code>, allows us to create a render fragment that will render a component (of type <code>TComponent</code>) with the specified parameters.<br>
The <code>ChildContent&lt;TComponent&gt;(...)</code> has the same parameter options as the <code>RenderComponent&lt;TComponent&gt;</code> method has.</li>
</ul>
<h2 id="testing-components-with-eventcallback-parameters">Testing components with <code>EventCallback</code> parameters</h2>
<p>To show how to pass an <code>EventCallback</code> to a component under test, we will use the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Components/ThemedButton.razor">ThemedButton.razor</a>, which looks like this:</p>
<pre><code class="lang-cshtml">&lt;button @onclick=&quot;HandleOnClick&quot;
        class=@Theme?.Value
        title=@Title?.Value
        @attributes=&quot;Attributes&quot;&gt;
    @ChildContent
&lt;/button&gt;
@code {
    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary&lt;string, object&gt;? Attributes { get; set; }

    [CascadingParameter] public ThemeInfo? Theme { get; set; }
    [CascadingParameter(Name = nameof(Title))] public ThemeInfo? Title { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public EventCallback&lt;MouseEventArgs&gt; OnClick { get; set; }

    private Task HandleOnClick(MouseEventArgs args) =&gt; OnClick.InvokeAsync(args);
}
</code></pre>
<p>The relevant part of <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/tests/Tests/Components/ThemedButtonTest.cs">ThemedButtonTest.cs</a> looks like this:</p>
<pre><code class="lang-csharp">public class ThemedButtonTest : ComponentTestFixture
{
    [Fact(DisplayName = &quot;When button is clicked, the OnClick event callback is triggered&quot;)]
    public void Test001()
    {
        var wasCalled = false;
        // Arrange - pass a lambda in as parameter to the OnClick parameter.
        //
        // This is equivalent to the follow Razor code:
        //
        // &lt;ThemedButton OnClick=&quot;(_) =&gt; wasCalled = true&quot;&gt;&lt;/ThemedButton&gt;
        var cut = RenderComponent&lt;ThemedButton&gt;(
            EventCallback(nameof(ThemedButton.OnClick), (MouseEventArgs _) =&gt; wasCalled = true)
        );

        // Act - click the button in CUT
        cut.Find(&quot;button&quot;).Click();

        // Assert - check if callback was triggered
        wasCalled.ShouldBeTrue();
    }
}
</code></pre>
<p><code>Test001</code> above uses the <code>EventCallback(parammeterName, callback)</code> helper method the generate a proper <code>EventCallback</code> object. There are many overloads, that should enable all the normal scenarios that is possible via Razor code.</p>
<h2 id="testing-components-with-cascading-value-parameters">Testing components with cascading-value parameters</h2>
<p>If a component under test accepts cascading values, like <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Components/ThemedButton.razor">ThemedButton.razor</a> listed above, we can pass one or more cascading values to it like so:</p>
<pre><code class="lang-csharp">public class ThemedButtonTest : ComponentTestFixture
{
    [Fact(DisplayName = &quot;Themed button uses provided theme info to set class attribute&quot;)]
    public void Test002()
    {
        // Arrange - create an instance of the ThemeInfo class to passs to the ThemedButton
        var theme = new ThemeInfo() { Value = &quot;BUTTON&quot; };

        // Act - Render the ThemedButton component, passing in the instance of ThemeInfo
        // as an _unnamed_ cascading value.
        //
        // This is equivalent to the follow Razor code:
        //
        // &lt;CascadingValue Value=&quot;theme&quot;&gt;
        //     &lt;ThemedButton&gt;&lt;/ThemedButton&gt;
        // &lt;/CascadingValue&gt;
        var cut = RenderComponent&lt;ThemedButton&gt;(
            CascadingValue(theme)
        );

        // Assert - check that the class specified in the cascading value was indeed used.
        cut.Find(&quot;button&quot;).ClassList.ShouldContain(theme.Value);
    }

    [Fact(DisplayName = &quot;Named cascading values are passed to components&quot;)]
    public void Test003()
    {
        // Arrange - create two instances of the ThemeInfo class to passs to the ThemedButton
        var theme = new ThemeInfo() { Value = &quot;BUTTON&quot; };
        var titleTheme = new ThemeInfo() { Value = &quot;BAR&quot; };

        // Act - Render the ThemedButton component, passing in the instances of ThemeInfo
        // as an _unnamed_ and a _named_ cascading value.
        //
        // This is equivalent to the follow Razor code:
        //
        // &lt;CascadingValue Value=&quot;theme&quot;&gt;
        //     &lt;CascadingValue Name=&quot;Title&quot; Value=&quot;titleTheme&quot;&gt;
        //         &lt;ThemedButton&gt;&lt;/ThemedButton&gt;
        //     &lt;/CascadingValue&gt;
        // &lt;/CascadingValue&gt;
        var cut = RenderComponent&lt;ThemedButton&gt;(
            CascadingValue(theme),
            CascadingValue(nameof(ThemedButton.Title), titleTheme)
        );

        // Assert - check that the class and title specified in the cascading values was indeed used.
        var elm = cut.Find(&quot;button&quot;);
        elm.ClassList.ShouldContain(theme.Value);
        elm.GetAttribute(&quot;title&quot;).ShouldContain(titleTheme.Value);
    }
}
</code></pre>
<ul>
<li><code>Test002</code> above uses the <code>CascadingValue(object value)</code> helper method to pass an <strong>unnamed</strong> cascading value to the CUT.</li>
<li><code>Test003</code> above demonstrates how multiple (named) cascading values can be passed to a component under test.</li>
</ul>
<h2 id="testing-components-that-use-on-ijsruntime">Testing components that use on <code>IJSRuntime</code></h2>
<p>It is not uncommon to have components use Blazor's JSInterop functionality to call JavaScript, e.g. after first render.</p>
<p>To make it easy to mock calls to JavaScript, the library comes with a <code>IJSRuntime</code> mocking helper, that allows you to specify return how JSInterop calls should be handled, and to verify that they have happened.</p>
<p>If you have more complex mocking needs, you could look to frameworks like <a href="https://github.com/Moq">Moq</a> or <a href="https://github.com/telerik/JustMockLite">JustMock Lite</a>, which both work nicely with bUnit.</p>
<p>To help us test the Mock JSRuntime, we have the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Components/WikiSearch.razor">WikiSearch.razor</a> component, which looks like this:</p>
<pre><code class="lang-cshtml">@inject IJSRuntime jsRuntime

&lt;p&gt;@searchResult&lt;/p&gt;

@code {
    string searchResult = string.Empty;

    // Assumes the following function is available in the DOM
    // &lt;script&gt;
    //     function queryWiki(query) {
    //         return fetch('https://en.wikipedia.org/w/api.php?origin=*&amp;action=opensearch&amp;search=' + query)
    //             .then(x =&gt; x.text());
    //     }
    // &lt;/script&gt;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            searchResult = await jsRuntime.InvokeAsync&lt;string&gt;(&quot;queryWiki&quot;, &quot;blazor&quot;);
            StateHasChanged();
        }
    }
}
</code></pre>
<p>The <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/tests/Tests/Components/WikiSearchTest.cs">WikiSearchTest.cs</a> looks like this:</p>
<pre><code class="lang-csharp">public class WikiSearchTest : ComponentTestFixture
{
    [Fact(DisplayName = &quot;WikiSearch renders an empty P element initially&quot;)]
    public void Test001()
    {
        // Arrange
        // Registered the MockJSRuntime in &quot;Loose&quot; mode with the service provider used when rendering components.
        // JSRuntimeMockMode.Loose is the default. It configures the mock to just return the default
        // value for whatever is requested in a InvokeAsync call if no call has explicitly been set up.
        var jsMock = Services.AddMockJSRuntime();

        // Act - render the WikiSearch component
        var cut = RenderComponent&lt;WikiSearch&gt;();

        // Assert
        // Check that the components initial HTML is as expected
        // and that the mock was called with the expected JS identifier and arguments.
        cut.MarkupMatches(&quot;&lt;p&gt;&lt;/p&gt;&quot;);
        jsMock.VerifyInvoke(&quot;queryWiki&quot;).Arguments.Single().ShouldBe(&quot;blazor&quot;);
    }

    [Fact(DisplayName = &quot;On first render WikiSearch uses JSInterop to query wiki and display the result&quot;)]
    public void Test002()
    {
        // Arrange
        // Registered the MockJSRuntime in &quot;strict&quot; mode with the service provider used when rendering components.
        // JSRuntimeMockMode.Strict mode configures the mock to throw an error if it receives an InvokeAsync call
        // it has not been set up to handle.
        var jsMock = Services.AddMockJSRuntime(JSRuntimeMockMode.Strict);

        // Set up the mock to handle the expected call
        var expectedSearchResult = &quot;SEARCH RESULT&quot;;
        var plannedInvocation = jsMock.Setup&lt;string&gt;(&quot;queryWiki&quot;, &quot;blazor&quot;);

        // Render the WikiSearch and verify that there is no content in the paragraph element
        var cut = RenderComponent&lt;WikiSearch&gt;();
        cut.Find(&quot;p&quot;).InnerHtml.ShouldBeEmpty();

        // Act
        // Use the WaitForNextRender to block until the component has finished re-rendered.
        // The plannedInvocation.SetResult will return the result to the component is waiting
        // for in its OnAfterRender from the await jsRuntime.InvokeAsync&lt;string&gt;(&quot;queryWiki&quot;, &quot;blazor&quot;) call.
        WaitForNextRender(() =&gt; plannedInvocation.SetResult(expectedSearchResult));

        // Assert
        // Verify that the result was received and correct placed in the paragraph element.
        cut.Find(&quot;p&quot;).InnerHtml.ShouldBe(expectedSearchResult);
    }
}
</code></pre>
<ul>
<li><p><code>Test001</code> just injects the mock in &quot;Loose&quot; mode. It means it will only returns a <code>default(TValue)</code> for calls to <code>InvokeAsync&lt;TValue&gt;(...)</code> it receives. This allows us to test components that expects a <code>IJSRuntime</code> to be injected, but where the test we want to perform isn't dependent on it providing any specific return value.</p>
<p>In &quot;Loose&quot; mode it is still possible to call <code>VerifyInvoke(identifier)</code> and assert against the expected invocation.</p>
</li>
<li><p><code>Test002</code> injects and configures the mock in strict mode. That requires us to configure all the expected calls the mock should handle. If it receives a call it has not been configured for, an exception is thrown and the test fails.</p>
</li>
<li><p>The <code>WaitForNextRender(Action)</code> helper method is used to block until a (async) render completes, that the action passed to it has triggered.
In <code>Test002</code> we trigger a render by setting the result on the planned invocation, which causes the <code>await jsRuntime.InvokeAsync&lt;string&gt;(&quot;queryWiki&quot;, &quot;blazor&quot;)</code> call in the CUT to complete, and the component to trigger a re-render by calling the <code>StateHasChanged()</code> method.</p>
</li>
</ul>
<h3 id="verifying-element-references-passed-to-invokeasync">Verifying element references passed to InvokeAsync</h3>
<p>If you want to verify that a element reference (<code>ElementReference</code>) passed to a IJSRuntime.InvokeAsync call is references the expected DOM element, you can do so with the <code>ShouldBeElementReferenceTo()</code> assert helper.</p>
<p>For example, consider the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Components/FocussingInput.razor">FocussingInput.razor</a> component, which looks like this:</p>
<pre><code class="lang-cshtml">@inject IJSRuntime jsRuntime

&lt;input @ref=&quot;_inputRef&quot; @attributes=&quot;Attributes&quot; /&gt;

@code {
    private ElementReference _inputRef;

    [Parameter(CaptureUnmatchedValues = true)]
    public IReadOnlyDictionary&lt;string, object&gt;? Attributes { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await jsRuntime.InvokeVoidAsync(&quot;document.body.focus.call&quot;, _inputRef);
        }
    }
}
</code></pre>
<p>The the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/tests/Tests/Components/FocussingInputTest.cs">FocussingInputTest.cs</a> looks like this:</p>
<pre><code class="lang-csharp">public class FocussingInputTest : ComponentTestFixture
{
    [Fact(DisplayName = &quot;After first render, the new input field has focus&quot;)]
    public void Test001()
    {
        // Arrange - add the IJSRuntime mock
        var jsRtMock = Services.AddMockJSRuntime();

        // Act - render the FocussingInput component, causing
        // the OnAfterRender(firstRender: true) to be called
        var cut = RenderComponent&lt;FocussingInput&gt;();

        // Assert
        // that there is a single call to document.body.focus.call
        var invocation = jsRtMock.VerifyInvoke(&quot;document.body.focus.call&quot;);
        // Assert that the invocation received a single argument
        // and that it was a reference to the input element.
        var expectedReferencedElement = cut.Find(&quot;input&quot;);
        invocation.Arguments.Single().ShouldBeElementReferenceTo(expectedReferencedElement);
    }
}
</code></pre>
<p>The last line verifies that there was a single argument to the invocation, and via the <code>ShouldBeElementReferenceTo</code> checks, that the <code>&lt;input /&gt;</code> was indeed the referenced element.</p>
<h2 id="testing-components-with-injected-dependencies">Testing components with injected dependencies</h2>
<p>The demonstrate service injection, lets refactor the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Pages/FetchData.razor">FetchData.razor</a> component that comes with the default Razor app template, to make it more testable:</p>
<ul>
<li><p>Extract an interface from <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Data/WeatherForecastService.cs">WeatherForecastService</a>, name it <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Data/IWeatherForecastService.cs">IWeatherForecastService</a>, and have <code>FetchData</code> take a dependency on it.</p>
</li>
<li><p>Extract the <code>&lt;table&gt;</code> inside the <code>else</code> branch in the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Pages/FetchData.razor">FetchData.razor</a> component into its own component. Lets name it <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Pages/FetchData.razor">ForecastDataTable</a>.</p>
</li>
<li><p>In the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Pages/FetchData.razor">FetchData.razor</a>, pass the variable <code>forecasts</code> to the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/src/Pages/FetchData.razor">ForecastDataTable</a> component.</p>
</li>
</ul>
<p>Now we just need a <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/tests/MockForecastService.cs">MockForecastService.cs</a>. It looks like this:</p>
<pre><code class="lang-csharp">internal class MockForecastService : IWeatherForecastService
{
    public TaskCompletionSource&lt;WeatherForecast[]&gt; Task { get; } = new TaskCompletionSource&lt;WeatherForecast[]&gt;();
    public Task&lt;WeatherForecast[]&gt; GetForecastAsync(DateTime startDate) =&gt; Task.Task;
}
</code></pre>
<p>With the mock in place, we can write the <a href="https://github.com/egil/razor-components-testing-library/tree/main/sample/tests/Tests/Pages/FetchDataTest.cs">FetchDataTest.cs</a>, which looks like this:</p>
<pre><code class="lang-csharp">public class FetchDataTest : ComponentTestFixture
{
    [Fact(DisplayName = &quot;Fetch data component renders expected initial markup&quot;)]
    public void Test001()
    {
        // Arrange - add the mock forecast service
        Services.AddSingleton&lt;IWeatherForecastService, MockForecastService&gt;();

        // Act - render the FetchData component
        var cut = RenderComponent&lt;FetchData&gt;();

        // Assert that it renders the initial loading message
        var initialExpectedHtml = @&quot;&lt;h1&gt;Weather forecast&lt;/h1&gt;
                                    &lt;p&gt;This component demonstrates fetching data from a service.&lt;/p&gt;
                                    &lt;p&gt;&lt;em&gt;Loading...&lt;/em&gt;&lt;/p&gt;&quot;;
        cut.MarkupMatches(initialExpectedHtml);
    }

    [Fact(DisplayName = &quot;After data loads it is displayed in a ForecastTable component&quot;)]
    public void Test002()
    {
        // Setup the mock forecast service
        var forecasts = new[] { new WeatherForecast { Date = DateTime.Now, Summary = &quot;Testy&quot;, TemperatureC = 42 } };
        var mockForecastService = new MockForecastService();
        Services.AddSingleton&lt;IWeatherForecastService&gt;(mockForecastService);

        // Arrange - render the FetchData component
        var cut = RenderComponent&lt;FetchData&gt;();

        // Act - pass the test forecasts to the component via the mock services
        WaitForNextRender(() =&gt; mockForecastService.Task.SetResult(forecasts));

        // Assert
        // Render an new instance of the ForecastDataTable, passing in the test data
        var expectedDataTable = RenderComponent&lt;ForecastDataTable&gt;((nameof(ForecastDataTable.Forecasts), forecasts));
        // Assert that the CUT has two changes, one removal of the loading message and one addition which matched the
        // rendered HTML from the expectedDataTable.
        cut.GetChangesSinceFirstRender().ShouldHaveChanges(
            diff =&gt; diff.ShouldBeRemoval(&quot;&lt;p&gt;&lt;em&gt;Loading...&lt;/em&gt;&lt;/p&gt;&quot;),
            diff =&gt; diff.ShouldBeAddition(expectedDataTable)
        );
    }
}
</code></pre>
<ul>
<li><p>In <code>Test001</code> we use the <code>Services.AddSingleton</code> method to register the dependency and the performs a regular &quot;initial render&quot; verification.</p>
</li>
<li><p><code>Test002</code> creates a new instance of the mock service and registers that with the the service provider. It then renders the CUT and uses <code>WaitForNextRender</code> to pass the test data to the mock services task, which then completes and the CUT gets the data.</p>
</li>
<li><p>In the assert step we expect the CUT to use a <code>ForecastDataTable</code> to render the forecast data. Thus, to make our assertion more simple and stable to changes, we render an instance of the <code>ForecastDataTable</code> use that to verify that the expected addition after the CUT receives the forecast data is as it should be.</p>
</li>
</ul>
<h2 id="dispatching-on-events-during-testing">Dispatching <code>@on-events</code> during testing</h2>
<p>In the previous sections we have seen a few examples of method calls that trigger <code>@on-event</code> handlers, e.g. <code>cut.Find(selector).Click()</code> that triggers the <code>@onclick</code> event handler attached to the element that matches the search query.</p>
<p>The following triggers are currently available in PascalCase, without the <code>@on</code>-prefix. E.g. the <code>@onbeforeactivate</code> event is available as <code>BeforeActivate()</code> in various overloads.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/egil/bUnit/blob/main/docs/site/docs/csharp-test-examples.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <small>Documentation updated on 7/15/2020 10:04:21 AM +00:00 in commit acbc0e07cf</small>.
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/cshtml-razor.js"></script>
    <script>
      hljs.registerLanguage('cshtml-razor', window.hljsDefineCshtmlRazor);
    </script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
